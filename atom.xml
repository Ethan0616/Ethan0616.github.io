<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大葱油饼的博客</title>
  
  <subtitle>煎饼大葱我最爱</subtitle>
  <link href="https://ethan0616.github.io/Ethan0616.github.io/atom.xml" rel="self"/>
  
  <link href="https://ethan0616.github.io/Ethan0616.github.io/"/>
  <updated>2022-02-07T01:57:59.657Z</updated>
  <id>https://ethan0616.github.io/Ethan0616.github.io/</id>
  
  <author>
    <name>Ethan Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS逆向开发（八）LLDB 动态调试</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios08/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios08/</id>
    <published>2022-02-06T12:54:40.000Z</published>
    <updated>2022-02-07T01:57:59.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h3><ol><li><p>将手机中的debugserver 拷贝到电脑<br>scp <a href="mailto:&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#x38;&#46;&#51;&#49;&#46;&#x32;&#x30;&#x30;">&#114;&#111;&#x6f;&#x74;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#x38;&#46;&#51;&#49;&#46;&#x32;&#x30;&#x30;</a>:/Developer/usr/bin/debugserver ~/Desktop/debugserver</p></li><li><p>导出原有权限<br>ldid -e debugserver &gt; debugserver.entitlements</p></li><li><p>需要给予更高权限 </p></li></ol><ul><li>get-task-allow</li><li>task_for_pid-allow<br>plist增加上述两个字段 条布尔类型 yes </li></ul><p>临时增加：<br>删除Debugserver文件下的<br>com.apple.security.network.server<br>com.apple.security.network.client<br>seatbelt-profiles<br>调试的时候报错，省的回来重新签名，提前删掉</p><ol start="4"><li><p>重新签名<br>ldid -Sdebugserver.entitlements debugserver</p></li><li><p>导入到手机<br>scp ~/Desktop/debugserver <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#x40;&#49;&#x39;&#50;&#46;&#49;&#54;&#x38;&#x2e;&#51;&#x31;&#x2e;&#x32;&#48;&#x30;">&#x72;&#111;&#x6f;&#x74;&#x40;&#49;&#x39;&#50;&#46;&#49;&#54;&#x38;&#x2e;&#51;&#x31;&#x2e;&#x32;&#48;&#x30;</a>:/usr/bin/debugserver</p></li><li><p>在手机中给到debugserver权限<br>chmod +x /usr/bin/debugserver </p></li></ol><h1 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h1><ol><li>先建立usb连接，参考装机必备 注意两个端口号 第二个是debugserver的调试通道<br>python /Users/ethan/Desktop/iOSRE/usbmuxd-1.0.8/python-client/tcprelay.py -t 22:10010 10011:10011<br>ssh root@localhost -p 10010</li><li>调试命令<br>debugserver *: 端口号 -a 进程</li></ol><ul><li>注：</li><li>可用ps -A查询</li><li>端口号不要与手机ssh 连接的22 重复即可</li></ul><p>最终连接命令：<br>debugserver localhost:10011 -a “name”</p><ol start="3"><li>Mac 连接<br>process connect connect://localhost:10011<br><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%882.20.32.png"></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%882.20.32-1.png"></p><p>lldb监听成功：<br><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%882.46.40.png"></p><p>c  程序继续</p><p>参考文章 : <a href="https://iosre.com/t/debugserver-lldb-gdb/65">https://iosre.com/t/debugserver-lldb-gdb/65</a></p><p><img src="ALLR%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97.png" alt="ALLR偏移地址计算"></p><p>logify.pl 类名.h &gt;&gt; 追加到abc.xm<br>在 tweak 中增加文件需要更改目录 修改 tweak_name_FILES = $(wildcard src/*.xm)</p><p>有错误 需要自己声明；<br><img src="%E6%88%AA%E5%B1%8F2022-01-08%20%E4%B8%8B%E5%8D%885.32.47.png"></p><p>cmd + shift + f 查找替换掉编译错误的地方。</p><h1 id="LLDB-命令"><a href="#LLDB-命令" class="headerlink" title="LLDB 命令"></a>LLDB 命令</h1><h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><p><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%883.21.32.png"></p><h3 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h3><p>expression + 可执行代码，可对App动态注入代码，不需要重新运行</p><h3 id="修改寄存器的值"><a href="#修改寄存器的值" class="headerlink" title="修改寄存器的值"></a>修改寄存器的值</h3><p>register write r0 0</p><h3 id="lldb-启动一个App"><a href="#lldb-启动一个App" class="headerlink" title="lldb 启动一个App"></a>lldb 启动一个App</h3><p>debugserver -x backboard *:1234 /path/to/app/executable<br>debugserver -x backboard *:1234 /Applications/MobileNotes.app/MobileNotes</p><p><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%883.56.18.png"></p><h3 id="打印函数调用堆栈"><a href="#打印函数调用堆栈" class="headerlink" title="打印函数调用堆栈"></a>打印函数调用堆栈</h3><p>thread backtrace  -&gt; 简写 tb<br>frame 代表栈帧<br><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%883.52.41.png"></p><h3 id="打印断点命令："><a href="#打印断点命令：" class="headerlink" title="打印断点命令："></a>打印断点命令：</h3><p>白盒：<br>breakpoint set -n test  -&gt; 给test函数增加断点<br>黑盒：<br>breakpoint set -a 函数地址 -&gt; -a 也可以用 –address 在函数地址上增加断点</p><p>内存地址上打断点<br>br s -a 0xb446+0x9a000<br>br s -a 0xA5446</p><p>thread return 直接在断点处返回，如有返回值，后接值</p><p>Source level 源码级别的单步运行 (源码的单步)<br>s n<br>s: 遇到函数进入<br>n: 遇到函数跳过</p><p>Instruction level 指令级别的单步运行(汇编指令)<br>ni: thread step-inst-over<br>si: thread step-inst</p><p><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%884.13.54.png"></p><p>breakpoint set -r 接正则<br>breakpoint list 查看所有断点<br>breakpoint delete 断点编号<br>移除所有断点<br><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%884.41.07.png"></p><p>breakpoint command add 2  -&gt; 给指定断点添加编号<br><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%884.26.12.png"></p><p>watchpoint set variable self-&gt;_age<br>当内存断点触发后，可以用bt指令查看具体在哪里调用了指令</p><p>watchpoint set expression 地址值</p><p>watchpoint delete 1 删除断点</p><h1 id="模块查找"><a href="#模块查找" class="headerlink" title="模块查找"></a>模块查找</h1><p>image list </p><p>非常常用，当不显示具体崩溃位置，可以用这命令<br>image lookup -a 0x0000000102d9302c(内存地址)</p><p>image list -o -f  -&gt; 输出内存映射<br>第一列[X]是image的序号；<br>第二列是ASLR的offset（也就是对应image的虚拟内存slide）<br>第三列是image的全路径和slide之后的基地址，一般第二列就是我们需要的信息。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>enter : 会自动执行上次命令 即 回车键</p><p>读取方法名称 x/s $内存地址<br><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8B%E5%8D%884.20.55.png"></p><h3 id="恢复当前断点"><a href="#恢复当前断点" class="headerlink" title="恢复当前断点"></a>恢复当前断点</h3><p>c: Process is running.  Use ‘process interrupt’ to pause execution.</p><p>process interrupt </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环境搭建：&quot;&gt;&lt;a href=&quot;#环境搭建：&quot; class=&quot;headerlink&quot; title=&quot;环境搭建：&quot;&gt;&lt;/a&gt;环境搭建：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将手机中的debugserver 拷贝到电脑&lt;br&gt;scp &lt;a href=&quot;mailto:&amp;#1</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（七）脱壳过程</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios07/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios07/</id>
    <published>2022-02-06T12:53:30.000Z</published>
    <updated>2022-02-06T12:55:29.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三种加壳方式"><a href="#三种加壳方式" class="headerlink" title="三种加壳方式"></a>三种加壳方式</h3><ul><li>VM  壳</li><li>加密 壳</li><li>压缩 壳</li></ul><h3 id="三种脱壳方式：目前用第三种"><a href="#三种脱壳方式：目前用第三种" class="headerlink" title="三种脱壳方式：目前用第三种"></a>三种脱壳方式：目前用第三种</h3><ul><li>Clutch<br>原理：posix_spawnp创建进程然后dump直接生成ipa包在设备，可以说是很方便了。这个是工具在使用的时候大部分应用会出报错，此外生成的包还需要自己拷贝。</li><li>dumpdecrypted<br>地址： <a href="https://github.com/stefanesser/dumpdecrypted">https://github.com/stefanesser/dumpdecrypted</a><br>原理： 通过手动注入然后启动应用程序在内存进行dump解密后的内存实现砸壳，这种砸壳只能砸主App可执行文件。有动态库不行<br>对于应用程序里面存在framework的情况可以使用conradev的<a href="https://github.com/conradev/dumpdecrypted">https://github.com/conradev/dumpdecrypted</a>，通过_dyld_register_func_for_add_image注册回调对每个模块进行dump解密。</li><li>Frida-ios-dump 会被越狱检测出，直接闪退。</li><li>手动脱壳 </li><li>CrackerXI: iOS12 目前没法用dumpdecrypt、Clutch破壳。可以在cydia中直接安装CrackerXI+来破壳，更加方便快捷<br>CrackerXI使用地址:<a href="https://my.oschina.net/u/4624620/blog/4538834">https://my.oschina.net/u/4624620/blog/4538834</a></li></ul><h3 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h3><ol><li>手机越狱<br>iphone7 iOS14.5 非完美越狱<br>checkra1n 官网下载，<br>我是开启vpn开始的设置，不知道有没有影响。<br>进入uncOver 显示包内容 进入后 cd到终端<br>./checkra1n -c<br>勾选所有 显示上会有-v<br>错误不用管，等待就行。<br>视频地址：<a href="https://www.bilibili.com/video/BV14T4y1F7kr/">https://www.bilibili.com/video/BV14T4y1F7kr/</a></li><li>安装手机越狱插件</li></ol><ul><li>AppleFileConduit “2” (ifunbox 沙盒查看目录用)</li><li>OpenSSH  (wifi连接用,需要手动修改密码，看工具篇)</li></ul><h1 id="一、Clutch-脱壳"><a href="#一、Clutch-脱壳" class="headerlink" title="一、Clutch 脱壳"></a>一、Clutch 脱壳</h1><p>Clutch: <a href="https://github.com/KJCracks/Clutch/releases/tag/2.0.4">https://github.com/KJCracks/Clutch/releases/tag/2.0.4</a><br>下载后去掉版本号 拖入手机/usr/bin目录</p><p>可执行权限不足<br><img src="%E6%88%AA%E5%B1%8F2022-01-07%20%E4%B8%8B%E5%8D%886.46.37.png"><br>chmod +x /usr/bin/Clutch</p><p>命令：Clutch -i  ，查询当前可脱壳应用，只显示未脱壳。<br>Clutch -d  加数组</p><h1 id="二、dumpdecrypted-脱壳"><a href="#二、dumpdecrypted-脱壳" class="headerlink" title="二、dumpdecrypted 脱壳"></a>二、dumpdecrypted 脱壳</h1><p><img src="classdump.png"></p><ol><li>下载 dumpdecrypted<br> 下载地址： <a href="https://github.com/stefanesser/dumpdecrypted">https://github.com/stefanesser/dumpdecrypted</a><br> make编译出 dumpdecrypted.dylib 文件</li><li>将 dumpdecrypted.dylib 文件导入到手机的/var/root目录 （越狱设备root权限）ifunbox 工具拖入 ，注意：如果链接两台设备 ifunbox失效</li><li>修改环境变量 DYLD_INSERT_LIBRARIES<br> 运行程序，输入 ps -A | grep 程序名称  找到进程id<br> cycript -p 6183 可进入调试，这里不需要调试，只需要目录路径。也可以进入后用mj的cycript工具找到路径<br> ps后路径为：<br>  6183 ??         0:00.00 /var/containers/Bundle/Application/E7039FC4-15B2-4EF0-8C16-878C04E34504/smoba.app/smoba<br>  修改环境变量：<br>  DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/E7039FC4-15B2-4EF0-8C16-878C04E34504/smoba.app/smoba</li><li>执行 DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/E7039FC4-15B2-4EF0-8C16-878C04E34504/smoba.app/smoba  注意：var 前有/</li><li>查询是否已脱壳 otool -l smoba.decrypted | grep crypt<br> cryptid 0 代表已脱壳</li></ol><p>查看BundleID<br>cat /var/containers/Bundle/Application/E7039FC4-15B2-4EF0-8C16-878C04E34504/smoba.app/Info.plist | grep CFBundleIdentifier -A 1<br>iOS10 以上需要重新签名 才能加载。</p><p>以上为旧版本脱壳<br>新版本脱壳参考 <a href="https://bbs.pediy.com/thread-263907.htm">https://bbs.pediy.com/thread-263907.htm</a></p><p>su mobile 切换到 mobile权限</p><p>找不到文件<br><img src="%E6%88%AA%E5%B1%8F2022-01-07%20%E4%B8%8B%E5%8D%8812.36.27.png"></p><p>重签名：</p><h2 id="列出可签名证书"><a href="#列出可签名证书" class="headerlink" title="列出可签名证书"></a>列出可签名证书</h2><p>security find-identity -v -p codesigning</p><h2 id="为dumpecrypted-dylib签名"><a href="#为dumpecrypted-dylib签名" class="headerlink" title="为dumpecrypted.dylib签名"></a>为dumpecrypted.dylib签名</h2><p>codesign –force –verify –verbose –sign “iPhone Developer: xxx xxxx (xxxxxxxxxx)” dumpdecrypted.dylib</p><p>其他总结：<br>最后su mobile，脱壳成功。我也是Meridian越狱，iPhone5s iOS10.3.2。<br>总结一下：<br>1、编译出dumpdecrypted.dylib，并且签名好。<br>2、将dumpdecrypted.dylib放到手机/usr/lib目录。<br>3、找到要脱壳应用的Documents路径，cd到Documents下。<br>4、su mobile切换到mobile用户。<br>5、DYLD_INSERT_LIBRARIES=/usr/lib/dumpdecrypted.dylib /var/containers/Bundle/Application/1F4B0FA7-4D39-4BA4-A563-E56B679975FB/XXXXXX.app/XXXXXX<br>正常就会脱壳成功了<br><a href="https://iosre.com/t/ios-10-2-dumpdecrypted-file-system-sandbox-blocked-mmap-abort-trap-6/13878/8">https://iosre.com/t/ios-10-2-dumpdecrypted-file-system-sandbox-blocked-mmap-abort-trap-6/13878/8</a></p><h1 id="三、Frida-ios-dump-一键砸壳"><a href="#三、Frida-ios-dump-一键砸壳" class="headerlink" title="三、Frida-ios-dump 一键砸壳"></a>三、Frida-ios-dump 一键砸壳</h1><p>cydia添加软件源<a href="https://build.frida.re/">https://build.frida.re/</a><br>安装Frida</p><p>电脑配置参考文章<br>缺什么 model 就单独安装<br><a href="https://iosre.com/t/frida-ios-dump/11640">https://iosre.com/t/frida-ios-dump/11640</a><br><a href="https://iosre.com/t/topic/10890">https://iosre.com/t/topic/10890</a><br>下载后需要手动配置端口号及iphone密码，在dump.py文件中。<br>iproxy 10010 22  开启监听<br>由于Mac设备不兼容 这里指定用python3 ,在Frida-ios-dump目录中<br>python3 ./dump.py -l 查看手机中的应用名称及 bundleid<br>sudo python3 ./dump.py 包名/名称<br>执行完会解压到当前目录。</p><p>加sudo<br><img src="%E6%88%AA%E5%B1%8F2022-01-08%20%E4%B8%8B%E5%8D%883.41.34.png"></p><h1 id="四、手动脱壳"><a href="#四、手动脱壳" class="headerlink" title="四、手动脱壳"></a>四、手动脱壳</h1><p><a href="https://iosre.com/t/lldb/8603">https://iosre.com/t/lldb/8603</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;三种加壳方式&quot;&gt;&lt;a href=&quot;#三种加壳方式&quot; class=&quot;headerlink&quot; title=&quot;三种加壳方式&quot;&gt;&lt;/a&gt;三种加壳方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;VM  壳&lt;/li&gt;
&lt;li&gt;加密 壳&lt;/li&gt;
&lt;li&gt;压缩 壳&lt;/li&gt;
&lt;/ul&gt;
&lt;h3</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（六）Theos 使用</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios06/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios06/</id>
    <published>2022-02-06T12:52:50.000Z</published>
    <updated>2022-02-06T12:55:44.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><p>**<br>git clone –recursive <a href="https://github.com/theos/theos.git">https://github.com/theos/theos.git</a><br>**<br>ssl 443<br>git config –global –unset http.proxy<br>git config –global –unset https.proxy</p><h3 id="2-修改环境变量："><a href="#2-修改环境变量：" class="headerlink" title="2. 修改环境变量："></a>2. 修改环境变量：</h3><p><img src="%E6%88%AA%E5%B1%8F2021-12-25%20%E4%B8%8B%E5%8D%882.31.41.png"></p><p>make 不成功 <a href="https://www.cnblogs.com/fply/p/8476242.html">https://www.cnblogs.com/fply/p/8476242.html</a></p><h3 id="3-命令：nic-pl"><a href="#3-命令：nic-pl" class="headerlink" title="3. 命令：nic.pl"></a>3. 命令：nic.pl</h3><p><img src="%E6%88%AA%E5%B1%8F2021-12-25%20%E4%B8%8B%E5%8D%882.43.14.png"></p><p>编译： make<br>打包： make package<br>打包后会有个文件夹 packages 里面会有deb文件，是越狱设备的插件，能直接运行在越狱设备上。</p><p>dylib目录： hook/firsthook/.theos/obj/debug </p><h3 id="4-Makefile-文件说明"><a href="#4-Makefile-文件说明" class="headerlink" title="4. Makefile 文件说明"></a>4. Makefile 文件说明</h3><p>export THEOS_DEVICE_IP=192.168.31.56<br>export THEOS_DEVICE_PORT=22</p><p>TARGET := iphone:clang:latest:8.0</p><p>include $(THEOS)/makefiles/common.mk</p><p>ARCHS = armv7 arm64<br>TWEAK_NAME = iosSwim<br>iosSwim_FILES = Tweak.x<br>iosSwim_CFLAGS = -fobjc-arc<br>iosSwim_FRAMEWORKS = UIKit</p><p>include $(THEOS_MAKE_PATH)/tweak.mk</p><p>after-install::<br>    install.exec “killall -9 SpringBoard”</p><h3 id="5-增加文件及目录"><a href="#5-增加文件及目录" class="headerlink" title="5. 增加文件及目录"></a>5. 增加文件及目录</h3><p><img src="theos%E5%A2%9E%E5%8A%A0%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95.png"></p><p>支持通配符 video84<br><img src="%E6%88%AA%E5%B1%8F2022-01-05%20%E4%B8%8B%E5%8D%881.47.11.png"></p><p>// 加载动态库时调用 %ctor<br>// 程序结束的时候调用 %deor</p><p>release  版本<br>make package debug=0<br><img src="%E6%88%AA%E5%B1%8F2022-01-05%20%E4%B8%8B%E5%8D%882.18.13-2.png"><br><img src="%E6%88%AA%E5%B1%8F2022-01-05%20%E4%B8%8B%E5%8D%882.31.57.png"><br><img src="theos%E5%A2%9E%E5%8A%A0%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95-1.png"></p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.jianshu.com/p/5d353d6db145">参考文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-下载&quot;&gt;&lt;a href=&quot;#1-下载&quot; class=&quot;headerlink&quot; title=&quot;1. 下载&quot;&gt;&lt;/a&gt;1. 下载&lt;/h3&gt;&lt;p&gt;**&lt;br&gt;git clone –recursive &lt;a href=&quot;https://github.com/theos</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（五）工具篇</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios05/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios05/</id>
    <published>2022-02-06T12:51:10.000Z</published>
    <updated>2022-02-06T15:16:43.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><img src="%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91.png"></p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><img src="%E6%88%AA%E5%B1%8F2022-01-03%20%E4%B8%8A%E5%8D%889.38.54-1.png"></p><p>如果Cydia下载不了，可以在网上下载后 借用ifunbox手动拖入到到沙盒的目录中安装<br><img src="%E6%88%AA%E5%B1%8F2022-01-03%20%E4%B8%8A%E5%8D%889.42.06.png"></p><h3 id="越狱后安装补丁、插件"><a href="#越狱后安装补丁、插件" class="headerlink" title="越狱后安装补丁、插件"></a>越狱后安装补丁、插件</h3><ul><li> cycript 调试工具</li><li> class-dump </li><li> Reveal  手机、Mac均安装</li></ul><h3 id="class-dump-常用方法："><a href="#class-dump-常用方法：" class="headerlink" title="class-dump 常用方法："></a>class-dump 常用方法：</h3><p>赋予 class-dump权限   chmod +x class-dump<br>class-dump  -H  Mach-O文件路径  -o  头文件存放目录<br>-H表示要生成头文件<br>-o用于制定头文件的存放目录</p><h4 id="OpenSSL-免密码登录"><a href="#OpenSSL-免密码登录" class="headerlink" title="OpenSSL 免密码登录"></a>OpenSSL 免密码登录</h4><p>SSL 是一种传输安全协议。<br>SSH 是 建立连接的通道，基于安全协议防止中间人攻击。<br>ssh-copy-id <a href="mailto:&#x72;&#x6f;&#111;&#x74;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#x33;&#49;&#46;&#x35;&#x36;">&#x72;&#x6f;&#111;&#x74;&#64;&#x31;&#57;&#x32;&#x2e;&#x31;&#x36;&#x38;&#46;&#x33;&#49;&#46;&#x35;&#x36;</a><br>命令ssh-copy-id  的作用是将客户端 .ssh 中.pub 公钥 追加到服务器的授权文件authorized_keys中</p><p><img src="%E6%88%AA%E5%B1%8F2022-01-03%20%E4%B8%8A%E5%8D%8811.15.46.png"></p><p>cat id_rsa.pub &gt;&gt; authorized_keys 将文件pub内容追加到authoried文件中<br>如果还是权限不足，需要给文件夹赋值权限<br>chmod 755 ~<br>chmod 755 ~/.ssh<br>chmod 644 ~/.ssh/authorized_keys</p><p>端口是主机服务器对外服务的窗口，0~65535  2的16次方的端口数量。<br>端口号有固定服务类别<br>21端口 提供FTP服务<br>80端口 提供HTTP服务<br>22端口 提供SSH服务 </p><h4 id="Openssh-登录用户手机"><a href="#Openssh-登录用户手机" class="headerlink" title="Openssh 登录用户手机"></a>Openssh 登录用户手机</h4><p>ssh <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#46;&#51;&#49;&#46;&#53;&#54;">&#114;&#x6f;&#111;&#116;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#46;&#51;&#49;&#46;&#53;&#54;</a>  密码 在越狱手机的openssh 上HOW do<br>默认密码： alpine<br>命令： passwd  -&gt; 修改密码 当前Wang_501<br>passwd mobile  账户密码一样</p><p>端口映射 使用USB 数据线连接<br><img src="%E6%88%AA%E5%B1%8F2022-01-03%20%E4%B8%8B%E5%8D%882.58.39.png"></p><p>下载后 usbmuxd-1.0.8/python-client 路径下在终端执行如下代码：<br>python tcprelay.py -t 22:10010  </p><p>开启端口映射后，打开新的终端窗口<br>ssh root@localhost -p 10010<br>连接到本地映射</p><hr><h3 id="cycript"><a href="#cycript" class="headerlink" title="cycript"></a>cycript</h3><p>Cycript 用来在调试手机中的越狱应用，需要在越狱手机中的Cydia中安装<br>cycript 使用 需要后面跟进程ID<br>cycript -p SpringBoard<br>cycript -p 3303<br>cycript -p 应用名称<br>取消输入： Ctrl + C<br>退出: Ctrl + D</p><p> mj 工具 github地址： <a href="https://github.com/CoderMJLee/mjcript.git">https://github.com/CoderMJLee/mjcript.git</a><br>安装到手机 ：<br> scp -P 10010 ./mjcript.cy root@localhost:/usr/lib/cycript0.9/mjcript.cy</p><hr><p>PS命令： Cydia 中安装adv-cmds<br>用来查看进程状态<br>ps -A  : 列出所有进程<br>ps -A | grep 关键字    : 搜索关键字</p><p>将本地文件拷贝到手机中<br>scp [参数] [源文件路径] [目标路径]<br>scp -P 2222 MainBinary root@localhost:/var<br>scp -P 10010 /Users/ethan/Desktop/etool.js root@localhost:/usr/lib/cycript0.9/etool.cy</p><p>记录一个带空格的目录 需要引号加转义字符<br> scp -P 10010 ./RevealServer root@localhost://Library/“Application\ Support”/CCRevealLoader/RevealServer.framework/RevealServer</p><p>ObjectiveC.classes  命令 查看所有使用的类<br>*#0x10e620ab0  查看当前指针的所有成员变量<br><img src="%E6%88%AA%E5%B1%8F2022-01-04%20%E4%B8%8B%E5%8D%884.30.05.png"></p><p>基本语法：<br>view.recursiveDescription().toString()<br>choose(UIViewController)</p><p>python 下查询unicode 数值<br> unicode(‘登录’,’UTF-8’)</p><hr><h3 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h3><p> 可视化开发调试：</p><ol><li>RevealLoader 使用 cydia 中下载 RevealLoader </li><li>在设置中找到RevealLoader  打开要调试的应用</li><li>把Mac版本的RevealServer 拖拽到iPhone上 <ul><li>路径： 点击Mac 上的Reveal 点击 help -&gt; show reveal library in finder -&gt; iOS Library 找到RevealServer ，拖入到/Library/Application Support/CCRevealLoader/RevealServer.framework中</li><li>也可能是/Library/Frameworks/RevealServer.framework路径，手机</li></ul></li><li>重启设备 killall SpringBoard  ; reboot</li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>问题：ifunbox 无法查看越狱设备的系统目录<br>解决: <a href="https://iosre.com/t/ifunbox-pp-iphone/10547">cydia中安装插件 Apple File Conduit “2”</a></p><p>问题： make install 不成功  重新修改了plist文件的大小写，均小写解决。</p><p>问题： ==&gt; Unloading SpringBoard…</p><p><a href="https://iosre.com/t/tweak-hook-hook/17131">这篇文章 重新安装dpkg</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;%E9%80%86%E5%90%91%E5%BC%80%E5%8F%91.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;软件安装&quot;</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（四）ARM64汇编</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios04/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios04/</id>
    <published>2022-02-06T12:37:10.000Z</published>
    <updated>2022-02-06T12:59:29.787Z</updated>
    
    <content type="html"><![CDATA[<ul><li>寄存器</li><li>指令</li><li>堆栈</li><li>中断 （不重要）</li></ul><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8810.39.23.png"></p><p>通用寄存器<br>64bit: x0~x28  共有29个寄存器 一个寄存器8个字节</p><p>可在代码中内嵌汇编代码<br><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8810.58.29.png"></p><p>汇编的注释 -&gt;  ;<br>x0 通常拿来存放函数的返回值<br>x0 ~ x7 通常拿来存放函数的参数，更多的参数使用堆栈来传递<br>cmp 指令 compare  比较的意思，将两个参数相减，相减的结果放在cpsr寄存器中<br>程序状态寄存器: cpsr、spsr<br>cpsr : Current Program Status Register<br>spsr:  Saved Program Status Register (异常状态下使用)</p><h3 id="cpsr"><a href="#cpsr" class="headerlink" title="cpsr"></a>cpsr</h3><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8811.23.45.png"><br><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8811.25.13.png"></p><h3 id="b-跳转指令"><a href="#b-跳转指令" class="headerlink" title="b 跳转指令"></a>b 跳转指令</h3><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8811.32.50.png"></p><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8811.33.28.png"></p><p>b 与 bl 的区别 bl 调用函数才能回到函数下一个位置，返回</p><h3 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h3><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8B%E5%8D%882.25.49.png"></p><h4 id="CPU寻址方式"><a href="#CPU寻址方式" class="headerlink" title="CPU寻址方式"></a>CPU寻址方式</h4><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8B%E5%8D%882.27.21.png"><br><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8B%E5%8D%882.33.37.png"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><img src="%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8B%E5%8D%882.50.41.png"></p><p>lr 存储着函数返回地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;li&gt;指令&lt;/li&gt;
&lt;li&gt;堆栈&lt;/li&gt;
&lt;li&gt;中断 （不重要）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;%E6%88%AA%E5%B1%8F2022-01-19%20%E4%B8%8A%E5%8D%8810.39.23.png</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（三）ASLR</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios03/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios03/</id>
    <published>2022-02-06T09:34:51.000Z</published>
    <updated>2022-02-06T12:59:15.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ASLR"><a href="#1-ASLR" class="headerlink" title="1. ASLR"></a>1. ASLR</h3><p>Address Space Layout Randomization,地址空间布局随机化<br>iOS4.3开始引入ASLR技术</p><h3 id="2-原理："><a href="#2-原理：" class="headerlink" title="2. 原理："></a>2. 原理：</h3><p> 是一种针对缓冲区移除的安全保护技术，通过对堆栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><h3 id="3-二进制文件分析"><a href="#3-二进制文件分析" class="headerlink" title="3. 二进制文件分析"></a>3. 二进制文件分析</h3><p>分析工具 ： hopper Disassembler </p><h3 id="4-Mach-O-载入内存中数据分区"><a href="#4-Mach-O-载入内存中数据分区" class="headerlink" title="4. Mach-O 载入内存中数据分区"></a>4. Mach-O 载入内存中数据分区</h3><p><img src="%E6%88%AA%E5%B1%8F2022-01-12%20%E4%B8%8B%E5%8D%885.24.09.png"><br>RawData 存放两部分： __TEXT、__DATA<br>VM Address: Virtual Memory Address 内存地址，开始位置<br>VM Size : Virtual Memory Size 内存大小<br>File Offset: 在Mach-O 文件中的位置<br>File Size: 在Mach-O 文件中占据的大小</p><p>函数代码存放在__TEXT中<br>全局变量存放在__DATA中</p><p>DATA在载入内存会比原来的大一些，留意下即可。<br>函数在载入内存地址值是固定的，函数调用的变量需要在堆与栈空间重新开辟。<br>hopper 展示的是没有ASLR的地址，减掉pagezero地址就是有ASLR地址。</p><p><img src="02.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-ASLR&quot;&gt;&lt;a href=&quot;#1-ASLR&quot; class=&quot;headerlink&quot; title=&quot;1. ASLR&quot;&gt;&lt;/a&gt;1. ASLR&lt;/h3&gt;&lt;p&gt;Address Space Layout Randomization,地址空间布局随机化&lt;br&gt;iOS4</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（二）注入重签名</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios02/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios02/</id>
    <published>2022-02-06T09:33:47.000Z</published>
    <updated>2022-02-06T12:58:59.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mach-O-LC-LOAD-DYLIB-Hook的方式："><a href="#Mach-O-LC-LOAD-DYLIB-Hook的方式：" class="headerlink" title="Mach-O  LC_LOAD_DYLIB Hook的方式："></a>Mach-O  LC_LOAD_DYLIB Hook的方式：</h3><p>利用Mach-O文件加载的方式，注入dylib文件，使其启动时加载我们新建的dylib文件，向未越狱App中注入.dylib </p><hr><h4 id="完整流程："><a href="#完整流程：" class="headerlink" title="完整流程："></a>完整流程：</h4><p><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8A%E5%8D%8810.48.11.png"></p><h3 id="1-撰写注入程序，-dylib-动态库"><a href="#1-撰写注入程序，-dylib-动态库" class="headerlink" title="1. 撰写注入程序，.dylib 动态库"></a>1. 撰写注入程序，.dylib 动态库</h3><p>参考内存编辑器篇文章</p><h3 id="2-获取脱壳-IPA"><a href="#2-获取脱壳-IPA" class="headerlink" title="2. 获取脱壳 IPA"></a>2. 获取脱壳 IPA</h3><h4 id="2-1-直接下载已脱壳ipa"><a href="#2-1-直接下载已脱壳ipa" class="headerlink" title="2.1 直接下载已脱壳ipa"></a>2.1 直接下载已脱壳ipa</h4><p>如果没有越狱设备，可以用这个网址下载，9块钱一次。<a href="https://www.dumpapp.com/">连接</a></p><h4 id="2-2-下载未脱壳ipa-，手动脱壳"><a href="#2-2-下载未脱壳ipa-，手动脱壳" class="headerlink" title="2.2 下载未脱壳ipa ，手动脱壳"></a>2.2 下载未脱壳ipa ，手动脱壳</h4><p>应用Apple configurator2 提取 ipa，App Store下载即可。<br><a href="https://blog.csdn.net/qq_19484963/article/details/112284365">使用连接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个路径下 取到ipa包</span></span><br><span class="line">~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</span><br></pre></td></tr></table></figure><p>不要替换，会有中间程序，就是这个ipa。</p><ul><li>Clutch 、dumpdecrypted <a href="https://iosre.com/t/lldb/8603">脱壳工具</a></li></ul><h4 id="2-3-校验ipa-是否已脱壳的办法"><a href="#2-3-校验ipa-是否已脱壳的办法" class="headerlink" title="2.3 校验ipa 是否已脱壳的办法"></a>2.3 校验ipa 是否已脱壳的办法</h4><h5 id="2-3-1-命令："><a href="#2-3-1-命令：" class="headerlink" title="2.3.1 命令："></a>2.3.1 命令：</h5><p>搜索是否已脱壳： otool -l AppName | grep crypt</p><h4 id="2-3-2-使用MachOView工具"><a href="#2-3-2-使用MachOView工具" class="headerlink" title="2.3.2 使用MachOView工具"></a>2.3.2 使用MachOView工具</h4><p>查看如下图字段，Crypt ID 如果是0 证明已脱壳，1为未脱壳<br><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8A%E5%8D%8811.15.26.png"></p><hr><h3 id="3-注入"><a href="#3-注入" class="headerlink" title="3. 注入"></a>3. 注入</h3><h4 id="3-1-注入工具："><a href="#3-1-注入工具：" class="headerlink" title="3.1 注入工具："></a>3.1 注入工具：</h4><ul><li>将.dylib注入到app的工具:yololib ,<a href="https://github.com/KJCracks/yololib">工具地址</a></li></ul><h5 id="3-1-1-命令格式："><a href="#3-1-1-命令格式：" class="headerlink" title="3.1.1 命令格式："></a>3.1.1 命令格式：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// binary : ipa 包内 二进制文件</span><br><span class="line">// dylib file :  自己之前生成的文件，含有hock代码。</span><br><span class="line">yololib binary dylib file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功截图：<br><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8B%E5%8D%8811.37.59.png"></p><pre><code>2. insert_dylib : insert_dylib @executable_path/IGG-For-ShiSanGe.dylib test --all-yes --weak test</code></pre><h5 id="3-1-2-查看注入结果-MathOView"><a href="#3-1-2-查看注入结果-MathOView" class="headerlink" title="3.1.2 查看注入结果 MathOView"></a>3.1.2 查看注入结果 MathOView</h5><p>注入后在MachOView 中搜索 dylib 文件名称，看是否已经注入成功。</p><h4 id="3-2-完整的注入流程"><a href="#3-2-完整的注入流程" class="headerlink" title="3.2 完整的注入流程"></a>3.2 完整的注入流程</h4><ol><li>theos 中打包  <pre><code> make 、 make package</code></pre></li><li>将路径中 的 dylib 文件导入到 被注入文件<pre><code> 路径：hook/firsthook/.theos/obj/debug </code></pre></li><li>otool -L 查看 theos 生成的dylib文件的依赖库，如有依赖一并导入</li><li>需要在被导入的包中的machO文件注入 启动加载的动态库 <pre><code> 命令：insert_dylib : insert_dylib @executable_path/IGG-For-ShiSanGe.dylib test --all-yes --weak test</code></pre></li><li>在theos 生成的dylib 文件中更改依赖库的查找连接 <pre><code> 命令： install_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate @loader_path/CydiaSubstrate IGG-For-ShiSanGe.dylib</code></pre></li><li>对包重新签名： <pre><code> 1. 查询证书id：security find-identity -v -p codesigning  2. 导入的库依赖的库都需要签名： codesign -fs C360C5C949130FF014A22EE008CA51574246BA37  动态库名称</code></pre></li><li>用iOS App Singer 对应用重签名，选择自己的ProvisioningProfile ，可以自己运行一个应用在应用生成的文件中导出名为： embedded.mobileprovision 的文件就是了。</li><li>安装： 用Xcode的Window的 Devices and Simulators 中点击+ 找到对应位置即可。</li></ol><hr><h3 id="4-重新签名"><a href="#4-重新签名" class="headerlink" title="4. 重新签名"></a>4. 重新签名</h3><h4 id="4-1-签名步骤："><a href="#4-1-签名步骤：" class="headerlink" title="4.1 签名步骤："></a>4.1 签名步骤：</h4><ul><li>修改动态库依赖路径</li><li>先签名动态库，otool -L 查看动态库依赖</li><li>依赖包与动态库都需要签名</li></ul><h5 id="4-1-1-替换frameworks路径"><a href="#4-1-1-替换frameworks路径" class="headerlink" title="4.1.1 替换frameworks路径"></a>4.1.1 替换frameworks路径</h5><p>install_name_tool -change @loader_path/DLGMemor @loader_path/Frameworks/DLGMemor IGG-For-ShiSanGe.dylib</p><h5 id="4-1-2-查询证书ID"><a href="#4-1-2-查询证书ID" class="headerlink" title="4.1.2 查询证书ID"></a>4.1.2 查询证书ID</h5><p>查询证书ID：security find-identity -v -p codesigning</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) C360C5C949130FF014A22EE008CA51574246BA37 &quot;Apple Development: 154800872@qq.com (72DR7G7U55)&quot;</span><br><span class="line">2) 0F0637F5B05253A05D7F545C3E069AFC27A2D496 &quot;Apple Development: 154800872@qq.com (72DR7G7U55)&quot;</span><br></pre></td></tr></table></figure><h5 id="4-1-3-依赖包与动态库都需要重签名："><a href="#4-1-3-依赖包与动态库都需要重签名：" class="headerlink" title="4.1.3 依赖包与动态库都需要重签名："></a>4.1.3 依赖包与动态库都需要重签名：</h5><p>codesign -fs C360C5C949130FF014A22EE008CA51574246BA37 –entitlements xxx.plist xxx.app</p><p><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8B%E5%8D%8810.24.09.png"></p><h4 id="4-2-重签名方式："><a href="#4-2-重签名方式：" class="headerlink" title="4.2 重签名方式："></a>4.2 重签名方式：</h4><h5 id="4-2-1-方式一：手动签名打包"><a href="#4-2-1-方式一：手动签名打包" class="headerlink" title="4.2.1 方式一：手动签名打包"></a>4.2.1 方式一：手动签名打包</h5><p>签名命令：<br>Payload目录外层操作</p><ul><li>security find-identity -v -p codesigning</li><li>security cms -D -i embedded.mobileprovision &gt; temp.plist</li><li>/usr/libexec/PlistBuddy -x -c ‘Print :Entitlements’ temp.plist &gt; entitlements.plist</li><li>rm temp.plist</li><li>cp entitlements.plist Payload   </li><li>cd Payload </li><li>codesign -fs C360C5C949130FF014A22EE008CA51574246BA37 –entitlements entitlements.plist smoba.app</li><li>rm entitlements.plist</li></ul><p>签名后打包成ipa</p><ul><li>Step1: 新建“Payload”文件夹，注意名字要一字不差；</li><li>Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称；</li><li>Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可</li></ul><h5 id="4-2-2-方式二：使用爱思助手-用个人开发者id-签名"><a href="#4-2-2-方式二：使用爱思助手-用个人开发者id-签名" class="headerlink" title="4.2.2 方式二：使用爱思助手 用个人开发者id 签名"></a>4.2.2 方式二：使用爱思助手 用个人开发者id 签名</h5><h5 id="4-2-3-方式三：重签名GUI-iOSAppSigner-常用-地址"><a href="#4-2-3-方式三：重签名GUI-iOSAppSigner-常用-地址" class="headerlink" title="4.2.3 方式三：重签名GUI iOSAppSigner 常用  地址"></a>4.2.3 方式三：重签名GUI iOSAppSigner 常用  <a href="https://github.com/DanTheMan827/ios-app-signer">地址</a></h5><hr><h3 id="5-问题与解决"><a href="#5-问题与解决" class="headerlink" title="5.问题与解决"></a>5.问题与解决</h3><h4 id="5-1-闪退："><a href="#5-1-闪退：" class="headerlink" title="5.1 闪退："></a>5.1 闪退：</h4><p>结果中有一段越狱手机中才会用到的CyduaSubstrate库。<br>我们需要用 libsubstrate.dylib替换这个库。</p><p><a href="https://github.com/kokoabim/iOSOpenDev/blob/master/lib/libsubstrate.dylib">下载地址</a></p><h4 id="5-2-修改动态库依赖路径后，提示如下："><a href="#5-2-修改动态库依赖路径后，提示如下：" class="headerlink" title="5.2 修改动态库依赖路径后，提示如下："></a>5.2 修改动态库依赖路径后，提示如下：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: changes being made to the file will invalidate the code signature in: IGG-For-ShiSanGe.dylib</span><br></pre></td></tr></table></figure><p>需要重新对动态库签名</p><h4 id="5-3-注入后签名失败"><a href="#5-3-注入后签名失败" class="headerlink" title="5.3 注入后签名失败"></a>5.3 注入后签名失败</h4><p>iOS签名校验机制<br><a href="https://segmentfault.com/a/1190000040812130?utm_source=sf-similar-article">内容连接</a></p><p><img src="%E6%88%AA%E5%B1%8F2021-12-24%20%E4%B8%8A%E5%8D%889.16.26.png"></p><h4 id="5-4-注入后闪退"><a href="#5-4-注入后闪退" class="headerlink" title="5.4 注入后闪退"></a>5.4 <a href="https://iosre.com/t/dylib/3463/7">注入后闪退</a></h4><p><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8A%E5%8D%8810.22.02.png"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653577384&idx=1&sn=b44a9c9651bf09c5bea7e0337031c53c&scene=0#wechat_redirect">腾讯</a></p><p><a href="https://github.com/iM0hamed/dylibInjecting">其他</a></p><p><a href="https://iosre.com/t/mach-o-lc-load-dylib-hook/2841">参考文章</a></p><p><a href="https://www.sohu.com/a/204756732_487493">dylib动态库注入和重签名打包</a></p><p><a href="https://blog.csdn.net/sun6223508/article/details/105098046">把.app文件打包ipa 利用Payload 打包ipa</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Mach-O-LC-LOAD-DYLIB-Hook的方式：&quot;&gt;&lt;a href=&quot;#Mach-O-LC-LOAD-DYLIB-Hook的方式：&quot; class=&quot;headerlink&quot; title=&quot;Mach-O  LC_LOAD_DYLIB Hook的方式：&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向开发（一）修改进程内存</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios01/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios01/</id>
    <published>2022-02-06T09:32:37.000Z</published>
    <updated>2022-02-06T12:58:27.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>当执行文件由操作系统运行时，就成为一个进程。<br>实际上可执行文件和处理同一个对象的不同状态，即一些数据和一组指令。我们可以将可执行文件视为静态，将进程视为动态。可执行文件在硬盘上，而进程“存储”在内存中。所以，进程包含数据和指令它们在内存中。</p><ul><li>优点： 能够及时反馈修改情况</li><li>缺点： 不能保存修改信息，应用重新加载后修改消失</li></ul><p><img src="02.png" alt="loadcommands"></p><h3 id="2-虚拟内存、内存页和内存区域"><a href="#2-虚拟内存、内存页和内存区域" class="headerlink" title="2. 虚拟内存、内存页和内存区域"></a>2. 虚拟内存、内存页和内存区域</h3><p>当操作系统执行一个可执行文件时，它会将这个可执行文件从硬盘加载到内存中。<br>这个进程在内存中的哪个位置？</p><p>每个进程都有自己独立的内存空间（即进程A与B运行在不同的内存区域），这是通过内存虚拟化来实现的。大部分操作系统都是基于虚拟内存，对于像ARMv7这样的32位处理器，每个进程的虚拟内存大小是2^32=4G字节大。但是大多数进程不需要4GB来运行，它们只消耗4GB的一小部分。一个进程实际使用的内存大小称为进程的虚拟地址空间，4GB虚拟空间被划分为很多很多的内存页进行分配，而内存页是“一个固定长度（iOS/OSX上为4096字节）的连续虚拟内存块，，它是内存操作的最小数据单位”。进程的虚拟内存地址空间由多个内存区域组成。每个内存区域包含多个虚拟内存页，注意内存区域可能不连续。</p><p><img src="03.png" alt="内存"></p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>无论代码编写成什么样子，最终都会被翻译成0和1。在虚拟内存地址中定位目标值，就像在段落中搜索字符串模式一样简单。</p><p>在我们的示例中，内存中有一个匹配模式，从第 11 个数字“0”开始，到第 16 个数字“1”结束。<br>在实际情况下，将二进制视为十六进制更容易。所以一段内存应该是这样的：</p><p><img src="01.png" alt="内存"></p><p>Oxfeedface可以看作是一个Mach-O文件开始的标记<br>请注意，像“0xfeedface”这样的每个块占用 4 个字节（因为 0xfe = 11111110 = 8 位 = 1 个字节），所以它就像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Address</span>    : <span class="type">Byte</span></span><br><span class="line"><span class="number">0x02cb2000</span> : <span class="number">0xfe</span></span><br><span class="line"><span class="number">0x02cb2001</span> : <span class="number">0xed</span></span><br><span class="line"><span class="number">0x02cb2002</span> : <span class="number">0xfa</span></span><br><span class="line"><span class="number">0x02cb2003</span> : <span class="number">0xce</span></span><br><span class="line"><span class="number">0x02cb2004</span> : <span class="number">0x00</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="number">0x02cb200c</span> : <span class="number">0x00</span></span><br><span class="line"><span class="number">0x02cb200d</span> : <span class="number">0x00</span></span><br><span class="line"><span class="number">0x02cb200e</span> : <span class="number">0x00</span></span><br><span class="line"><span class="number">0x02cb200f</span> : <span class="number">0x08</span></span><br></pre></td></tr></table></figure><p>如果我们的目标值是 int targetValue = 21592 == 0x5458，我们可以在地址 0x02cb2009 到 0x02cb200c 的内存段中找到它，对吗？但是，由于指令和其他数据也存储在内存中，因此 0x5458 可能只是指令的一部分，或者是长数的一部分（比如 0x0000545845545f5f。ARM 是小端），它可能不会呈现我们的 int 目标值。这种情况发生在我们的大多数内存搜索中，即可以找到多个匹配项。如果是这种情况，我们必须再次搜索更具体的值（我们稍后将在示例中对此进行研究）。现在我们知道“内存搜索”是什么意思了</p><p>了解了这些信息，尝试将内存编辑器建模：<br>功能如下：</p><ol><li>通过枚举所有虚拟内存区域，获取目标进程的虚拟内存地址空间；（这里要解决非越狱下不注入的情况下如何获取其他进程）</li><li>在地址空间中搜索我们需要的目标值，并且获得可能的目标值；</li><li>修改目标值；</li></ol><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>内存相关处理的函数 mach_vm <a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/osfmk/vm/vm_user.c">文档</a> $参数$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">mach_vm_read</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_map_t</span>                 <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_address_t</span>        addr,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_size_t</span>           size,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">pointer_t</span>                *data,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_msg_type_number_t</span>   *data_size)</span></span></span><br></pre></td></tr></table></figure><p>描述：从一个地址空间读取/复制一个范围并将其返回给调用者。$map$是要读取其内存的任务的端口；$addr$是开始读取的地址；$size$是要读取的字节数；$data$是用于存储读取字节的缓冲区；$data_size$在输入时，是指向缓冲区最大大小的指针；在输出上，指向读取的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">mach_vm_write</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_map_t</span>                         <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_address_t</span>                address,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">pointer_t</span>                        data,</span></span></span><br><span class="line"><span class="params"><span class="function">        __unused <span class="keyword">mach_msg_type_number_t</span>  size)</span></span>;</span><br></pre></td></tr></table></figure><p>描述：将数据写入目标任务地址空间中的指定地址。$map$是要写入其内存的任务的端口；$address$是开始写入的地址；$data$是要写入的缓冲区；$size$是 的大小$data$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">mach_vm_region</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_map_t</span>                <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_offset_t</span>        *address,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_size_t</span>          *size,                </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_region_flavor_t</span>      flavor,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_region_info_t</span>        info,                </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_msg_type_number_t</span>  *count,        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_port_t</span>             *object_name)</span></span>;</span><br></pre></td></tr></table></figure><p>描述：返回虚拟内存区域的描述。$map$是地址空间包含区域的任务的端口；$addr$在输入时，是开始寻找区域的地址；输出时，返回实际使用的起始地址；$size$输出是定位区域中的字节数；$flavor$是要返回的信息类型，应该是VM_REGION_BASIC_INFO；$info$返回区域信息，vm_region_basic_info_data_64_t在 32 位和 64 位操作系统上都应该是类型；$count$在输入时，应该是VM_REGION_BASIC_INFO_COUNT_64；在输出时，区域的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">memmem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *big, <span class="keyword">size_t</span> big_len, <span class="keyword">const</span> <span class="keyword">void</span> *little, <span class="keyword">size_t</span> little_len)</span></span>;</span><br></pre></td></tr></table></figure><p>描述：定位字节串$little$中第一次出现的字节串$big$。如果匹配，$little$则返回指向第一次出现的第一个字符的指针；否则它返回NULL。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>终端编译代码：<br>gcc main.m -o hello -ObjC -framework Foundation</p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><h4 id="reios论坛"><a href="#reios论坛" class="headerlink" title="reios论坛"></a><a href="http://bbs.iosre.com/t/write-a-simple-universal-memory-editor-game-trainer-on-osx-ios-from-scratch/115">reios论坛</a></h4><h4 id="DLGMemor-master"><a href="#DLGMemor-master" class="headerlink" title="DLGMemor-master"></a><a href="https://bbs.pediy.com/thread-226281.htm">DLGMemor-master</a></h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1. 原理&quot;&gt;&lt;/a&gt;1. 原理&lt;/h3&gt;&lt;p&gt;当执行文件由操作系统运行时，就成为一个进程。&lt;br&gt;实际上可执行文件和处理同一个对象的不同状态，即一些数据和一组指令。我</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
</feed>
