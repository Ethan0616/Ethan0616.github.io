<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大葱油饼的博客</title>
  
  <subtitle>煎饼大葱我最爱</subtitle>
  <link href="https://ethan0616.github.io/Ethan0616.github.io/atom.xml" rel="self"/>
  
  <link href="https://ethan0616.github.io/Ethan0616.github.io/"/>
  <updated>2022-02-06T10:48:20.353Z</updated>
  <id>https://ethan0616.github.io/Ethan0616.github.io/</id>
  
  <author>
    <name>Ethan Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>越狱开发原理（二）注入重签名</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios02/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios02/</id>
    <published>2022-02-06T09:43:44.326Z</published>
    <updated>2022-02-06T10:48:20.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mach-O-LC-LOAD-DYLIB-Hook的方式："><a href="#Mach-O-LC-LOAD-DYLIB-Hook的方式：" class="headerlink" title="Mach-O  LC_LOAD_DYLIB Hook的方式："></a>Mach-O  LC_LOAD_DYLIB Hook的方式：</h3><p>利用Mach-O文件加载的方式，注入dylib文件，使其启动时加载我们新建的dylib文件，向未越狱App中注入.dylib </p><hr><h4 id="完整流程："><a href="#完整流程：" class="headerlink" title="完整流程："></a>完整流程：</h4><p><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8A%E5%8D%8810.48.11.png"></p><h3 id="1-撰写注入程序，-dylib-动态库"><a href="#1-撰写注入程序，-dylib-动态库" class="headerlink" title="1. 撰写注入程序，.dylib 动态库"></a>1. 撰写注入程序，.dylib 动态库</h3><p>参考内存编辑器篇文章</p><h3 id="2-获取脱壳-IPA"><a href="#2-获取脱壳-IPA" class="headerlink" title="2. 获取脱壳 IPA"></a>2. 获取脱壳 IPA</h3><h4 id="2-1-直接下载已脱壳ipa"><a href="#2-1-直接下载已脱壳ipa" class="headerlink" title="2.1 直接下载已脱壳ipa"></a>2.1 直接下载已脱壳ipa</h4><p>如果没有越狱设备，可以用这个网址下载，9块钱一次。<a href="https://www.dumpapp.com/">连接</a></p><h4 id="2-2-下载未脱壳ipa-，手动脱壳"><a href="#2-2-下载未脱壳ipa-，手动脱壳" class="headerlink" title="2.2 下载未脱壳ipa ，手动脱壳"></a>2.2 下载未脱壳ipa ，手动脱壳</h4><p>应用Apple configurator2 提取 ipa，App Store下载即可。<br><a href="https://blog.csdn.net/qq_19484963/article/details/112284365">使用连接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个路径下 取到ipa包</span></span><br><span class="line">~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</span><br></pre></td></tr></table></figure><p>不要替换，会有中间程序，就是这个ipa。</p><ul><li>Clutch 、dumpdecrypted <a href="https://iosre.com/t/lldb/8603">脱壳工具</a></li></ul><h4 id="2-3-校验ipa-是否已脱壳的办法"><a href="#2-3-校验ipa-是否已脱壳的办法" class="headerlink" title="2.3 校验ipa 是否已脱壳的办法"></a>2.3 校验ipa 是否已脱壳的办法</h4><h5 id="2-3-1-命令："><a href="#2-3-1-命令：" class="headerlink" title="2.3.1 命令："></a>2.3.1 命令：</h5><p>搜索是否已脱壳： otool -l AppName | grep crypt</p><h4 id="2-3-2-使用MachOView工具"><a href="#2-3-2-使用MachOView工具" class="headerlink" title="2.3.2 使用MachOView工具"></a>2.3.2 使用MachOView工具</h4><p>查看如下图字段，Crypt ID 如果是0 证明已脱壳，1为未脱壳<br><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8A%E5%8D%8811.15.26.png"></p><hr><h3 id="3-注入"><a href="#3-注入" class="headerlink" title="3. 注入"></a>3. 注入</h3><h4 id="3-1-注入工具："><a href="#3-1-注入工具：" class="headerlink" title="3.1 注入工具："></a>3.1 注入工具：</h4><ul><li>将.dylib注入到app的工具:yololib ,<a href="https://github.com/KJCracks/yololib">工具地址</a></li></ul><h5 id="3-1-1-命令格式："><a href="#3-1-1-命令格式：" class="headerlink" title="3.1.1 命令格式："></a>3.1.1 命令格式：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// binary : ipa 包内 二进制文件</span><br><span class="line">// dylib file :  自己之前生成的文件，含有hock代码。</span><br><span class="line">yololib binary dylib file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功截图：<br><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8B%E5%8D%8811.37.59.png"></p><pre><code>2. insert_dylib : insert_dylib @executable_path/IGG-For-ShiSanGe.dylib test --all-yes --weak test</code></pre><h5 id="3-1-2-查看注入结果-MathOView"><a href="#3-1-2-查看注入结果-MathOView" class="headerlink" title="3.1.2 查看注入结果 MathOView"></a>3.1.2 查看注入结果 MathOView</h5><p>注入后在MachOView 中搜索 dylib 文件名称，看是否已经注入成功。</p><h4 id="3-2-完整的注入流程"><a href="#3-2-完整的注入流程" class="headerlink" title="3.2 完整的注入流程"></a>3.2 完整的注入流程</h4><ol><li>theos 中打包  <pre><code> make 、 make package</code></pre></li><li>将路径中 的 dylib 文件导入到 被注入文件<pre><code> 路径：hook/firsthook/.theos/obj/debug </code></pre></li><li>otool -L 查看 theos 生成的dylib文件的依赖库，如有依赖一并导入</li><li>需要在被导入的包中的machO文件注入 启动加载的动态库 <pre><code> 命令：insert_dylib : insert_dylib @executable_path/IGG-For-ShiSanGe.dylib test --all-yes --weak test</code></pre></li><li>在theos 生成的dylib 文件中更改依赖库的查找连接 <pre><code> 命令： install_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate @loader_path/CydiaSubstrate IGG-For-ShiSanGe.dylib</code></pre></li><li>对包重新签名： <pre><code> 1. 查询证书id：security find-identity -v -p codesigning  2. 导入的库依赖的库都需要签名： codesign -fs C360C5C949130FF014A22EE008CA51574246BA37  动态库名称</code></pre></li><li>用iOS App Singer 对应用重签名，选择自己的ProvisioningProfile ，可以自己运行一个应用在应用生成的文件中导出名为： embedded.mobileprovision 的文件就是了。</li><li>安装： 用Xcode的Window的 Devices and Simulators 中点击+ 找到对应位置即可。</li></ol><hr><h3 id="4-重新签名"><a href="#4-重新签名" class="headerlink" title="4. 重新签名"></a>4. 重新签名</h3><h4 id="4-1-签名步骤："><a href="#4-1-签名步骤：" class="headerlink" title="4.1 签名步骤："></a>4.1 签名步骤：</h4><ul><li>修改动态库依赖路径</li><li>先签名动态库，otool -L 查看动态库依赖</li><li>依赖包与动态库都需要签名</li></ul><h5 id="4-1-1-替换frameworks路径"><a href="#4-1-1-替换frameworks路径" class="headerlink" title="4.1.1 替换frameworks路径"></a>4.1.1 替换frameworks路径</h5><p>install_name_tool -change @loader_path/DLGMemor @loader_path/Frameworks/DLGMemor IGG-For-ShiSanGe.dylib</p><h5 id="4-1-2-查询证书ID"><a href="#4-1-2-查询证书ID" class="headerlink" title="4.1.2 查询证书ID"></a>4.1.2 查询证书ID</h5><p>查询证书ID：security find-identity -v -p codesigning</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) C360C5C949130FF014A22EE008CA51574246BA37 &quot;Apple Development: 154800872@qq.com (72DR7G7U55)&quot;</span><br><span class="line">2) 0F0637F5B05253A05D7F545C3E069AFC27A2D496 &quot;Apple Development: 154800872@qq.com (72DR7G7U55)&quot;</span><br></pre></td></tr></table></figure><h5 id="4-1-3-依赖包与动态库都需要重签名："><a href="#4-1-3-依赖包与动态库都需要重签名：" class="headerlink" title="4.1.3 依赖包与动态库都需要重签名："></a>4.1.3 依赖包与动态库都需要重签名：</h5><p>codesign -fs C360C5C949130FF014A22EE008CA51574246BA37 –entitlements xxx.plist xxx.app</p><p><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8B%E5%8D%8810.24.09.png"></p><h4 id="4-2-重签名方式："><a href="#4-2-重签名方式：" class="headerlink" title="4.2 重签名方式："></a>4.2 重签名方式：</h4><h5 id="4-2-1-方式一：手动签名打包"><a href="#4-2-1-方式一：手动签名打包" class="headerlink" title="4.2.1 方式一：手动签名打包"></a>4.2.1 方式一：手动签名打包</h5><p>签名命令：<br>Payload目录外层操作</p><ul><li>security find-identity -v -p codesigning</li><li>security cms -D -i embedded.mobileprovision &gt; temp.plist</li><li>/usr/libexec/PlistBuddy -x -c ‘Print :Entitlements’ temp.plist &gt; entitlements.plist</li><li>rm temp.plist</li><li>cp entitlements.plist Payload   </li><li>cd Payload </li><li>codesign -fs C360C5C949130FF014A22EE008CA51574246BA37 –entitlements entitlements.plist smoba.app</li><li>rm entitlements.plist</li></ul><p>签名后打包成ipa</p><ul><li>Step1: 新建“Payload”文件夹，注意名字要一字不差；</li><li>Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称；</li><li>Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可</li></ul><h5 id="4-2-2-方式二：使用爱思助手-用个人开发者id-签名"><a href="#4-2-2-方式二：使用爱思助手-用个人开发者id-签名" class="headerlink" title="4.2.2 方式二：使用爱思助手 用个人开发者id 签名"></a>4.2.2 方式二：使用爱思助手 用个人开发者id 签名</h5><h5 id="4-2-3-方式三：重签名GUI-iOSAppSigner-常用-地址"><a href="#4-2-3-方式三：重签名GUI-iOSAppSigner-常用-地址" class="headerlink" title="4.2.3 方式三：重签名GUI iOSAppSigner 常用  地址"></a>4.2.3 方式三：重签名GUI iOSAppSigner 常用  <a href="https://github.com/DanTheMan827/ios-app-signer">地址</a></h5><hr><h3 id="5-问题与解决"><a href="#5-问题与解决" class="headerlink" title="5.问题与解决"></a>5.问题与解决</h3><h4 id="5-1-闪退："><a href="#5-1-闪退：" class="headerlink" title="5.1 闪退："></a>5.1 闪退：</h4><p>结果中有一段越狱手机中才会用到的CyduaSubstrate库。<br>我们需要用 libsubstrate.dylib替换这个库。</p><p><a href="https://github.com/kokoabim/iOSOpenDev/blob/master/lib/libsubstrate.dylib">下载地址</a></p><h4 id="5-2-修改动态库依赖路径后，提示如下："><a href="#5-2-修改动态库依赖路径后，提示如下：" class="headerlink" title="5.2 修改动态库依赖路径后，提示如下："></a>5.2 修改动态库依赖路径后，提示如下：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: changes being made to the file will invalidate the code signature in: IGG-For-ShiSanGe.dylib</span><br></pre></td></tr></table></figure><p>需要重新对动态库签名</p><h4 id="5-3-注入后签名失败"><a href="#5-3-注入后签名失败" class="headerlink" title="5.3 注入后签名失败"></a>5.3 注入后签名失败</h4><p>iOS签名校验机制<br><a href="https://segmentfault.com/a/1190000040812130?utm_source=sf-similar-article">内容连接</a></p><p><img src="%E6%88%AA%E5%B1%8F2021-12-24%20%E4%B8%8A%E5%8D%889.16.26.png"></p><h4 id="5-4-注入后闪退"><a href="#5-4-注入后闪退" class="headerlink" title="5.4 注入后闪退"></a>5.4 <a href="https://iosre.com/t/dylib/3463/7">注入后闪退</a></h4><p><img src="%E6%88%AA%E5%B1%8F2021-12-23%20%E4%B8%8A%E5%8D%8810.22.02.png"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653577384&idx=1&sn=b44a9c9651bf09c5bea7e0337031c53c&scene=0#wechat_redirect">腾讯</a></p><p><a href="https://github.com/iM0hamed/dylibInjecting">其他</a></p><p><a href="https://iosre.com/t/mach-o-lc-load-dylib-hook/2841">参考文章</a></p><p><a href="https://www.sohu.com/a/204756732_487493">dylib动态库注入和重签名打包</a></p><p><a href="https://blog.csdn.net/sun6223508/article/details/105098046">把.app文件打包ipa 利用Payload 打包ipa</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Mach-O-LC-LOAD-DYLIB-Hook的方式：&quot;&gt;&lt;a href=&quot;#Mach-O-LC-LOAD-DYLIB-Hook的方式：&quot; class=&quot;headerlink&quot; title=&quot;Mach-O  LC_LOAD_DYLIB Hook的方式：&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
  <entry>
    <title>逆向开发（一）修改进程内存</title>
    <link href="https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios01/"/>
    <id>https://ethan0616.github.io/Ethan0616.github.io/2022/02/06/reios01/</id>
    <published>2022-02-06T09:32:37.395Z</published>
    <updated>2022-02-06T09:48:39.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>当执行文件由操作系统运行时，就成为一个进程。<br>实际上可执行文件和处理同一个对象的不同状态，即一些数据和一组指令。我们可以将可执行文件视为静态，将进程视为动态。可执行文件在硬盘上，而进程“存储”在内存中。所以，进程包含数据和指令它们在内存中。</p><ul><li>优点： 能够及时反馈修改情况</li><li>缺点： 不能保存修改信息，应用重新加载后修改消失</li></ul><p><img src="02.png" alt="loadcommands"></p><h3 id="2-虚拟内存、内存页和内存区域"><a href="#2-虚拟内存、内存页和内存区域" class="headerlink" title="2. 虚拟内存、内存页和内存区域"></a>2. 虚拟内存、内存页和内存区域</h3><p>当操作系统执行一个可执行文件时，它会将这个可执行文件从硬盘加载到内存中。<br>这个进程在内存中的哪个位置？</p><p>每个进程都有自己独立的内存空间（即进程A与B运行在不同的内存区域），这是通过内存虚拟化来实现的。大部分操作系统都是基于虚拟内存，对于像ARMv7这样的32位处理器，每个进程的虚拟内存大小是2^32=4G字节大。但是大多数进程不需要4GB来运行，它们只消耗4GB的一小部分。一个进程实际使用的内存大小称为进程的虚拟地址空间，4GB虚拟空间被划分为很多很多的内存页进行分配，而内存页是“一个固定长度（iOS/OSX上为4096字节）的连续虚拟内存块，，它是内存操作的最小数据单位”。进程的虚拟内存地址空间由多个内存区域组成。每个内存区域包含多个虚拟内存页，注意内存区域可能不连续。</p><p><img src="03.png" alt="内存"></p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>无论代码编写成什么样子，最终都会被翻译成0和1。在虚拟内存地址中定位目标值，就像在段落中搜索字符串模式一样简单。</p><p>在我们的示例中，内存中有一个匹配模式，从第 11 个数字“0”开始，到第 16 个数字“1”结束。<br>在实际情况下，将二进制视为十六进制更容易。所以一段内存应该是这样的：</p><p><img src="01.png" alt="内存"></p><p>Oxfeedface可以看作是一个Mach-O文件开始的标记<br>请注意，像“0xfeedface”这样的每个块占用 4 个字节（因为 0xfe = 11111110 = 8 位 = 1 个字节），所以它就像：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Address</span>    : <span class="type">Byte</span></span><br><span class="line"><span class="number">0x02cb2000</span> : <span class="number">0xfe</span></span><br><span class="line"><span class="number">0x02cb2001</span> : <span class="number">0xed</span></span><br><span class="line"><span class="number">0x02cb2002</span> : <span class="number">0xfa</span></span><br><span class="line"><span class="number">0x02cb2003</span> : <span class="number">0xce</span></span><br><span class="line"><span class="number">0x02cb2004</span> : <span class="number">0x00</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="number">0x02cb200c</span> : <span class="number">0x00</span></span><br><span class="line"><span class="number">0x02cb200d</span> : <span class="number">0x00</span></span><br><span class="line"><span class="number">0x02cb200e</span> : <span class="number">0x00</span></span><br><span class="line"><span class="number">0x02cb200f</span> : <span class="number">0x08</span></span><br></pre></td></tr></table></figure><p>如果我们的目标值是 int targetValue = 21592 == 0x5458，我们可以在地址 0x02cb2009 到 0x02cb200c 的内存段中找到它，对吗？但是，由于指令和其他数据也存储在内存中，因此 0x5458 可能只是指令的一部分，或者是长数的一部分（比如 0x0000545845545f5f。ARM 是小端），它可能不会呈现我们的 int 目标值。这种情况发生在我们的大多数内存搜索中，即可以找到多个匹配项。如果是这种情况，我们必须再次搜索更具体的值（我们稍后将在示例中对此进行研究）。现在我们知道“内存搜索”是什么意思了</p><p>了解了这些信息，尝试将内存编辑器建模：<br>功能如下：</p><ol><li>通过枚举所有虚拟内存区域，获取目标进程的虚拟内存地址空间；（这里要解决非越狱下不注入的情况下如何获取其他进程）</li><li>在地址空间中搜索我们需要的目标值，并且获得可能的目标值；</li><li>修改目标值；</li></ol><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>内存相关处理的函数 mach_vm <a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/osfmk/vm/vm_user.c">文档</a> $参数$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">mach_vm_read</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_map_t</span>                 <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_address_t</span>        addr,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_size_t</span>           size,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">pointer_t</span>                *data,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_msg_type_number_t</span>   *data_size)</span></span></span><br></pre></td></tr></table></figure><p>描述：从一个地址空间读取/复制一个范围并将其返回给调用者。$map$是要读取其内存的任务的端口；$addr$是开始读取的地址；$size$是要读取的字节数；$data$是用于存储读取字节的缓冲区；$data_size$在输入时，是指向缓冲区最大大小的指针；在输出上，指向读取的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">mach_vm_write</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_map_t</span>                         <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_address_t</span>                address,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">pointer_t</span>                        data,</span></span></span><br><span class="line"><span class="params"><span class="function">        __unused <span class="keyword">mach_msg_type_number_t</span>  size)</span></span>;</span><br></pre></td></tr></table></figure><p>描述：将数据写入目标任务地址空间中的指定地址。$map$是要写入其内存的任务的端口；$address$是开始写入的地址；$data$是要写入的缓冲区；$size$是 的大小$data$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">mach_vm_region</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_map_t</span>                <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_offset_t</span>        *address,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_vm_size_t</span>          *size,                </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_region_flavor_t</span>      flavor,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">vm_region_info_t</span>        info,                </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_msg_type_number_t</span>  *count,        </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">mach_port_t</span>             *object_name)</span></span>;</span><br></pre></td></tr></table></figure><p>描述：返回虚拟内存区域的描述。$map$是地址空间包含区域的任务的端口；$addr$在输入时，是开始寻找区域的地址；输出时，返回实际使用的起始地址；$size$输出是定位区域中的字节数；$flavor$是要返回的信息类型，应该是VM_REGION_BASIC_INFO；$info$返回区域信息，vm_region_basic_info_data_64_t在 32 位和 64 位操作系统上都应该是类型；$count$在输入时，应该是VM_REGION_BASIC_INFO_COUNT_64；在输出时，区域的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">memmem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *big, <span class="keyword">size_t</span> big_len, <span class="keyword">const</span> <span class="keyword">void</span> *little, <span class="keyword">size_t</span> little_len)</span></span>;</span><br></pre></td></tr></table></figure><p>描述：定位字节串$little$中第一次出现的字节串$big$。如果匹配，$little$则返回指向第一次出现的第一个字符的指针；否则它返回NULL。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>终端编译代码：<br>gcc main.m -o hello -ObjC -framework Foundation</p><hr><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><h4 id="reios论坛"><a href="#reios论坛" class="headerlink" title="reios论坛"></a><a href="http://bbs.iosre.com/t/write-a-simple-universal-memory-editor-game-trainer-on-osx-ios-from-scratch/115">reios论坛</a></h4><h4 id="DLGMemor-master"><a href="#DLGMemor-master" class="headerlink" title="DLGMemor-master"></a><a href="https://bbs.pediy.com/thread-226281.htm">DLGMemor-master</a></h4><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1. 原理&quot;&gt;&lt;/a&gt;1. 原理&lt;/h3&gt;&lt;p&gt;当执行文件由操作系统运行时，就成为一个进程。&lt;br&gt;实际上可执行文件和处理同一个对象的不同状态，即一些数据和一组指令。我</summary>
      
    
    
    
    
    <category term="reios" scheme="https://ethan0616.github.io/Ethan0616.github.io/tags/reios/"/>
    
  </entry>
  
</feed>
